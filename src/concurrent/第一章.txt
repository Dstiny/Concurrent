

    线程安全的集合对象：
        Vector、HashTable、StringBuffer
    线程不安全集合：
        ArrayList、LinkedList、HashMap、HashSet、TreeMap、TreeSet、StringBuilder


    1.1 简介
        并发：单核处理器非顺序执行线程
        并行：多核处理器


    1.2  线程的创建和运行

        两种创建线程方式
        （1）继承Thread并且覆盖run()方法
        （2）创建一个实现Runnable接口的类，

        每个java程序至少一个执行线程，执行线程时JVM将启动这个执行线程老调用程序的main方法
        调用start方法时会创建另外一个线程
        所有的非守护线程结束这个程序结束
        某一个线程调用Syatem.exit()结束程序的执行
        实现Runnable接口的类来说创建一个Thread对象并不会闯将一个新的执行线程，需要调用start()方法才可以。



    1.3  线程信息的获取和设置

        Thread存在保存信息的属性，这些属性用来标识线程，显示线程的状态或控制线程优先级
        ID：保存线程唯一标识符
        Name：名字
        Priority：线程优先级，1-10，不推荐改变线程优先级
        Status：线程状态。线程状态6种，new（新建），runnable（可运行），blocked（被阻塞），
            waiting（等待），time waiting（计时等待），terminated（被终止）

        没有为线程指定名字，JVM会自动给他分配一个名字，格式thread-XX
        线程的ID和状态无法改变。


    1.4  线程的中断

        想终止一个程序，需要结束线程，java提供了中断机制
        这种机制要求检查是否被中断了，然后决定是否响应这个中断请求，线程允许忽略中断请求并且继续执行

        interrupt()
        interrupted()   静态方法
        isInterrupted()


    1.5  线程中断的控制
        如果线程实现了复杂算法并分布在几个方法内，或者线程存在递归调用的方法，使用一个更好的机制控制线程的中断
        为了达到这个目的，
        java提供了InterruptedException异常。当检查到线程中断的时候，就抛出这个异常然后在run()捕获并处理这个异常

        使用java异常控制线程的中断

        TimeUnit是可读性很好的线程暂停操作，用来代替Thread.sleep()。
        TimeUnit类解决Thread.sleep()可读性不好的问题
        通过指定DAYS,HOURS,MINUTES,SECONDS,...


    1.6  线程的休眠与恢复
        sometime，需要在一个预期的时间中断线程，如每隔一分钟检查一次传感器状态，其余时间什么都不做，空闲时间
        内线程不占用任何资源。
        可以通过sleep()达到目标。另一中方式是TimeUnit枚举类元素进行调用

        如果线程被中断，该方法会立即抛出InterruptedException，不需要等待休眠时间结束。

        另外一个方法使线程对象释放CPU，即yield()方法，它将通知JVM可以释放这个线程对象的CPU了，但不保证遵循这个要求


    1.7  等待线程的终止

        一些情况下必须等待线程终止时。例如，程序执行任务时必须初始化一些必须的资源，可以使用线程完成初始化任务，等待线程终止
        在执行其他任务
        为了达到这个目的使用Thread.join()方法。当一个线程对象的join方法调用时，调用它的线程将被挂起，
        直到这个线程对象完成它的任务。

        两种
            join()

            join(long milliseconds)
            join(long milliseconds,long nanos)
        满足两个条件终止：线程运行完毕、milliseconds达到毫秒数

    1.8  守护线程的创建和运行

            优先级很低。
            当守护线程是程序唯一一个运行的程序时，守护线程结束，jvm就结束了这个程序。
            称用户线程。
            通常是无线循环的，以等待服务器请求或者执行线程的任务。
            不能做重要工作，不知道什么时候能获取CPU时钟
            没有其他线程时，守护线程随时都可以结束。
            java垃圾回收机制
            setDaemon()是设置，在start()方法之前调用，线程开始就不能改变
            isDaemon()检查是否为守护线程


    1.9  线程不可控异常的处理

            java存在两种异常：
                非运行异常：这种异常需要在方法声明的throws语句指定货在方法体捕获异常，IOException,ClassNotFoundException
                运行异常：不必在方法中声明，也不需要捕获。如NumberFormatException

            因为run方法不支持throws语句，所以当线程抛出非运行异常时必须捕获并处理。
            当运行出现运行异常，默认行为是控制台打印堆栈记录并退出程序

            java提供一种在线程对象捕获和处理异常的一种机制.

            这种机制针对运行时异常的机制。

            当一个异常抛出没有被捕获时这种情况可能是运行异常，JVM检查这个线程是否被预制了未捕获异常处理器，找到，
            jvm会调用这个方法，并将线程对象和异常传入参数。
            setUncaughtExceptionHandler(...)

            Thread另外一个可以处理为捕获的异常，即静态方法setDefaultUncaughtExceptionHandler。
            这个方法为所有线程对象创建一个异常处理器

            当线程抛出一个异常时，JVM会寻找3中可能的处理器。

                寻找线程的未捕获异常处理器，找不到，线程对象所在线程组的未捕获异常处理器。还找不到，默认的
                未捕获异常处理器setDefaultUncaughtExceptionHandler。继续没有的话打印堆栈到控制台。


    1.10 线程局部变量的使用

        共享数据是并发核心问题。
        在一个线程中改变，所有线程都会被这个改变影响。
        某种情况下不需要被所有线程共享。java并发API提供一个干净的机制：局部变量

        ThreadLocal代表一个线程局部的变量，每个线程只能看到自己的值

        线程局部变量分别为每个线程储存了各自的属性值并提供给线程使用，可以使用get()读取，set()设置值
        如果线程第一次访问线程局部变量，线程局部变量可能没有为他存储值，这个时候initialValue()方法就会被调用，并返回值

        线程也提供remove方法为线程删除已存储的属性值

        java API InheritableThreadLocal如果一个线程从其他某个线程创建，这个类将提供继承的值。如果一个线程A在线程
        局部变量有有值，创建其他线程B之后，线程B的局部变量与A一样，可以覆盖childValue()方法，这个方法用来初始化子线程
        局部变量值。他使用父线程的局部变量值作为传入参数

    1.11 线程的分组

        允许把一组线程当做一个单元，对组内线程访问并操作。

        ThreadGroup类表示一组线程。

        线程组可以包含线程对象，也可以包含线程组对象。树形结构



    1.12 线程组中不可控异常的处理

    补货线程组中任何线程对象抛出非捕获异常

    线程组抛出非捕获异常，JVM寻找3中可能。
        线程的非捕获处理器
        线程组的非捕获异常处理器
        默认非捕获异常处理器
        打印控制台，退出程序

    1.13 使用工厂类创建线程

        工厂模式，使用工厂类可以将对象的创建集中化。
            好处：更容易修改类
            统计数量
            为有限资源创建对象数目

            ThreadFactory接口实现线程对象工厂,只有一个newThread方法，并且覆盖

            大多数线程工厂只有一行：return new Thread(r);

           可以增加变化创建个性化线程

