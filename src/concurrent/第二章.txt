

    1.1 简介
        多个执行线程共享一个资源，常见的并发编程情景之一

        常常遇到多个线程或者读写相同的数据，或访问相同的文件或数据库。为了防止这些共享资源可能出现错误或不一致，使用机制
        来防范

        临界区概念：代码块在同一时间只允许一个线程执行。

        java提供同步机制。当一个线程访问临界区时，它将使用一种同步机制来查看是不是有其他线程进入临界区。有的话，
        它被同步机制挂起，直到进入的线程离开这个临界区。

        如等待的不止一个，JVM会选择一个，其余的继续等待。

        本章：使用两种基本同步机制
            synchronized关键字机制、Lock接口机制


    1.2 使用synchronized实现同步方法

        synchronized修饰方法，类。临界区

        静态方法有不同行为，用synchronized关键字声明的静态方法，同时只能够被一个线程访问，但其他线层可以访问这个
        类的其他方法。谨慎使用，因为两个线程可以访问一个类的两个不同desynchronized方法，一个静态，一个非静态

        一个对象采用synchronized声明，只能被一个线程访问
        如果线程A执行一个同步方法，线程B要执行这个对象其他同步方法，线程B将阻塞直到线程A完毕。
        如果访问同一个类的不同对象，两线称胡不影响

        synchronized关键字会降低程序性能，因此只能在并发情境下修改数据使用

        可以递归调用被synchronized声明得方法。当线程访问一个对象同步方法时，他还可以调用这个对象的其他同步方法
        也包含正在执行的方法，而不必再次获取这个方法访问权

        可以通过synchronized板胡代码块的访问：方法的其余部分留在代码块外部，以获取更好的性能。即临界区尽可能短，
        ：synchronized(this){//code...}



    1.3 使用非依赖属性实现同步

        使用synchronized保护代码块时，必须把对象引用作为传入参数。通常情况下，使用this关键字来引用执行方法所属的对象。

        例如：类中有两个非依赖属性，被多个线程共享，必须同步一个每一个变量的访问，但同一时刻只允许一个线程访问一个
        属性变量，其他线程访问另一个变量

        我们使用synchronized保护代码块时使用对象为它传入参数，JVM保证同一时间一个线程


    1.4 在同步代码中使用条件

        生产者和消费者

        wait(),notify(),notifyAll()。
        同步代码块外调用wait会抛出异常
        wait()，JVM会将线程置入休眠，并释放控制这个同步代码块的对象

        其他线程调用notifyAll方法时，挂起的线程将被唤醒并在此检查这个条件


    1.5 使用锁实现同步

        java提供了同步代码块另一种机制，比synchronized更强大和灵活的机制
        reentrant 可重入的
        机制基于Lock及其实现类(如ReentrantLock)

        允许实现更加复杂的临界区。

        相比synchronized有了更多的功能。一个新功能是tryLock()方法的实现。试图获取锁，如果锁被其他线程获取，它将
        返回false并继续向下执行代码。
        使用tryLock()通过返回值将得知是否有其他线程正在使用这个锁保护的代码块

        优点：Lock允许分离读和写。允许多个线程只读和一个线程只写。Lock接口性能比synchronized好

        线程离开临界区时候必须使用unlock()释放持有的锁，否则其他线程永久等待，导致死锁。

        如果在临界区使用try-catch,一定将unLock()放入finally中


    1.6 使用读写锁实现同步数据访问

    锁机制最大改进之一是ReadWriteLock接口和他唯一实现类ReentrantReadWriteLock，这个类有两个锁，一个读，一个写。
    允许读操作可以有多个线程同时访问，写操作只能一个线程允许一个线程进行。
    在一个写操作时其他线程不能执行读操作


    1.7 修改锁的公平性

    ReentrantLock和ReentrantReadWriteLock类构造器含一个布尔参数fair，它允许控制两个雷行为。
    默认fair是false，称非公平模式，在这种模式下，当很多线程等待ReentrantLock和ReentrantLock锁时，锁将选择其中
    一个访问临界区。
    如果为true，公平模式，选择一个访问临界区，而且选择的是等待时间最长的。这两种模式只适用lock和unlock。而Lock接口
    的tryLock没有将线程置入休眠，fair并不影响这个方法。


    1.8 在锁中使用多条件

    一个锁可能关联一个或多个条件，这些条件通过Condition接口声明。目的允许线程获取锁并查看等待的某一个条件是否满足。
    不满足挂起知道某个线程唤醒他们。
    Condition接口提供了挂起线程和唤醒唤醒线程的机制

    与锁绑定的所有条件都是通过Lock接口声明的newCondition方法创建的。
    在使用条件时必须先获取这个条件绑定的锁，所以带条件的代码必须在lock和unlock方法之间

    当线程调用条件的await方法时它将自动释放这个条件的锁，其他某个线程才可以获取这个锁并执行相同的操作，或者执行
    锁保护的另外一个临界区代码。

    注意：当一个线程调用对象的signal或signalAll方法后，一个或多个在该条件挂起的线程将被唤醒，但这并不能保证让他们
    挂起的条件已满足，所以必须在while循环调用await，在条件成立之前不能离开这个循环。

    Condition提供其他形式：

    await(long time,TimeUnit unit)
    awaitUninterruptibly()  不可中断的，休眠直到调用signal或signalAll
    awaitUnit(Date date)

    也可以将条件与ReadLock和WriteLock一起使用